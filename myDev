#include "myDev.h"

#include <Servo.h>

#define inCharConverter (Serial.read() - 32)

#define servoNumber 5

#define total 7

Servo shouldeServo, elbowServo, wristServo, elbowRoll, handServo;

myDev myDev;

struct axisStat{
  uint16_t inPwm[total];
  uint16_t remainPwm[total];
  int8_t pwmMovement[total]; //
  uint16_t pt[total]; //ds3218 is range 600 to 2400
}; //servos pwm is cannot exceed specific value

struct axisStat Stat;

uint16_t minPwm;

/*
const uint8_t stepEna[3] = {8, 9, 10};
const uint8_t stepDir[3] = {11, 12, 13};
const uint8_t stepNo[3] = {14, 15, 16};

const uint8_t opticalSw[4] = {40, 41, 42, 43};

const uint8_t endSw[4] = {33, 34, 35, 36};
*/

uint8_t fibbo[10] = {1, 2, 3, 5, 8, 13, 21, 34, 56, 89};

int i;

uint8_t inChar;
uint8_t currentPin;

void setup() {
  Serial.begin(115200);
  myDev.registerPinEna(8, 9, 10);
  myDev.registerPinDir(11, 12, 13);
  myDev.registerPinStep(14, 15, 16);
  myDev.registerEndSw(22, 23, 24, 25);

  shouldeServo.attach(34);
  elbowServo.attach(35);
  wristServo.attach(36);
  elbowRoll.attach(37);
  handServo.attach(38);
}

//234 = end of char
/* 1. setting the curret control pin value
* 2. setting step per movement values(servo restricted 
* 3. setiing direcction. this will set negative or positive position
* 4. if direction is negative then stat.pwmmovement has negative value
* 5. seperate device moving every 0.025seconds
*  6. minimum movement is 800 microseconds
*/
void loop() {
  //myDev.homeAll();
  if (Serial.available()) {
    inChar = inCharConverter;
    //Serial.println (inChar);
    if (inChar >= 0 && inChar <= 94) {
      if (inChar >= 1 && inChar <= 7) {
        currentPin = inChar;
      } else if (inChar == 8 || inChar == 9) {
        
      } else if (inChar == 94) {
        Stat.pwmMovement[currentPin] = 2;
      }
    } //if end
  }
}

void finalWorker() {
  delayMicroseconds(findMinPwm());
}


uint16_t findMinPwm() {
  minPwm = Stat.remainPwm[0];
  for (i = 1; i < total; i++) {
    minPwm = min(minPwm, Stat.remainPwm[i]);
  }
  for (i = 0; i < total; i++) {
    Stat.remainPwm[i] -= minPwm;
    if (Stat.remainPwm[i] == 0) {
      Stat.remainPwm[i] = Stat.inPwm[i];
      Stat.pt[i] = (Stat.pt[i] + Stat.pwmMovement[i]); //pt rearrange
      worker(i);
    }
  }
  return minPwm; //using for delaymicroseconds
}


void worker(int i) {
  if (i == 5) {
    myDev.xAxisMovement();
  } else if (i == 6) {
    myDev.rAxisMovement();
  } else if (i == 0) {
    shouldeServo.writeMicroseconds(Stat.pt[0]);
  } else if (i == 1) {
    elbowServo.writeMicroseconds(Stat.pt[1]);
  } else if (i == 2) {
    wristServo.writeMicroseconds(Stat.pt[2]);
  } else if (i == 3) {
    elbowRoll.writeMicroseconds(Stat.pt[3]);
  } else if (i == 4) {
    handServo.writeMicroseconds(Stat.pt[4]);
  }
}
