#include "myDev.h"

#include "myAscii.h"

//#include <Servo.h>

#define inCharConverter (Serial.read() - 32)

#define inCharToPwm (inChar - 96)

#define servoNumber 5

#define total 7

//Servo shouldeServo, elbowServo, wristServo, elbowRoll, handServo;

myDev myDev;

myAscii myAscii2;

struct axisStat{
  uint16_t digit[3];
  uint16_t inPwm[total];
  uint16_t remainPwm[total];
  int8_t pwmMovement[total]; //
  uint16_t pt[total]; //ds3218 is range 600 to 2400
}; //servos pwm is cannot exceed specific value

struct axisStat Stat;

struct pwm{
  uint16_t digit[3];
  uint16_t remain;
  uint16_t in; // this value is sum of pwm.digit 1 to 3
};

struct pts{
  uint16_t target;
  uint16_t pt;
  uint8_t stepCount;
};


struct pwm pwm[total];
struct pts pts[total];

uint16_t minPwm;

/*
const uint8_t stepEna[3] = {8, 9, 10};
const uint8_t stepDir[3] = {11, 12, 13};
const uint8_t stepNo[3] = {14, 15, 16};

const uint8_t opticalSw[4] = {40, 41, 42, 43};

const uint8_t endSw[4] = {33, 34, 35, 36};
*/

uint8_t fibbo[10] = {1, 2, 3, 5, 8, 13, 21, 34, 56, 89};

int i;

char inChar;
uint8_t currentPin;

void setup() {
  Serial.begin(115200);
  
  #ifdef myDev_h
    myDev.registerPinEna(8, 9, 10);
    myDev.registerPinDir(11, 12, 13);
    myDev.registerPinStep(14, 15, 16);
    myDev.registerEndSw(22, 23, 24, 25);
  #endif
/*
  #ifndef Servo_h
    shouldeServo.attach(34);
    elbowServo.attach(35);
    wristServo.attach(36);
    elbowRoll.attach(37);
    handServo.attach(38);
  #endif
  */
}

//234 = end of char
/* 1. setting the curret control pin value
* 2. setting step per movement values(servo restricted 
* 3. setiing direcction. this will set negative or positive position
* 4. if direction is negative then stat.pwmmovement has negative value
* 5. seperate device moving every 0.025seconds
*  6. minimum movement is 800 microseconds
*/
void loop() {
  //myDev.asciiGet(8);
  //myDev.homeAll();
  if (Serial.available()) {
    inChar = Serial.read();
    settingProc();
  }
}

void settingProc() {
  //inChar = inCharConverter;
  //Serial.println (inChar);
  if (inChar >= 97 && inChar <= 125) {
    pwm[currentPin].in = myAscii2.asciiToPwm(inChar, &pwm[currentPin].digit[0], &pwm[currentPin].digit[1], &pwm[currentPin].digit[2]);
    Serial.print("current Pwm_");
    Serial.println(pwm[currentPin].in);
    Serial.print("seperate Pwm_");
    Serial.print(pwm[currentPin].digit[0]);
    Serial.print(pwm[currentPin].digit[1]);
    Serial.println(pwm[currentPin].digit[2]);    
  } else if (inChar >= 33 && inChar <= 40) {
    currentPin = (inChar - 33);
    Serial.print ("set Current Pin_");
    Serial.println (currentPin);
  }
}

void finalWorker() {
  delayMicroseconds(findMinPwm());
}


uint16_t findMinPwm() {
  minPwm = Stat.remainPwm[0];
  for (i = 1; i < total; i++) {
    minPwm = min(minPwm, Stat.remainPwm[i]);
  }
  for (i = 0; i < total; i++) {
    Stat.remainPwm[i] -= minPwm;
    if (Stat.remainPwm[i] == 0) {
      Stat.remainPwm[i] = Stat.inPwm[i];
      Stat.pt[i] = (Stat.pt[i] + Stat.pwmMovement[i]); //pt rearrange
      //worker(i);
    }
  }
  return minPwm; //using for delaymicroseconds
}



/*
void worker(int i) {
  if (i == 5) {
    myDev.xAxisMovement();
  } else if (i == 6) {
    myDev.rAxisMovement();
  } else if (i == 0) {
    shouldeServo.writeMicroseconds(Stat.pt[0]);
  } else if (i == 1) {
    elbowServo.writeMicroseconds(Stat.pt[1]);
  } else if (i == 2) {
    wristServo.writeMicroseconds(Stat.pt[2]);
  } else if (i == 3) {
    elbowRoll.writeMicroseconds(Stat.pt[3]);
  } else if (i == 4) {
    handServo.writeMicroseconds(Stat.pt[4]);
  }
}
*/
